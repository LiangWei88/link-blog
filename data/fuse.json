{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"伟's 博客首页","n":0.707},"1":{"v":"**找工作 ing**\n\n## 技能介绍\n\n### 开发技能\n- **基本技术**: html css javascript typescript\n- **前端框架**：精通 Vue.js（包括 Vue2 和 Vue3）、微信原生小程序、uniapp 以及鸿蒙 HarmonyOS next 开发\n- **后端和运维**：熟练使用 Node.js、空间托管年代配置过 apache, 后来在公司技术总监不在的时候也负责处理 nginx 部署\n- **预处理器**：熟练使用 Sass 和 Less\n- **工具与构建**：熟练使用 WebSocket、Webpack、Vite、鸿蒙 ArkTS 和 ArkUI\n- **数据库与后端语言**：在查找文档帮助下可以使用 MySQL 和 PHP（多年前熟练，现在放下了）\n- **脚本语言**：了解并试用过 Python，能够在 AI 帮助下编写脚本\n\n### 电脑美工\n\n- **图像处理**：熟练使用 Photoshop\n- **图形设计**：了解并能配合设计师处理 Illustrator\n\n### 编程框架\n\n- **前端框架**：十分熟练 Vue.js 和 jQuery\n- **CMS 和电子商务**：多年前用过 Magento、Opencart、Wordpress，学生时代用过 Joomla 和 Three.js、Zepto\n\n### 管理和规范化工具\n\n- **版本控制**：工作中使用 Git 和 GitHub Actions\n- **进程管理**：使用 pm2\n- **容器化**：使用 Docker\n\n### 运维\n\n- **Linux 环境**：基本 Linux 环境管理运维\n- **Web 服务器**：除了 Node.js 以外，可以查文档使用 Apache 和 Nginx\n\n### AI 人工智能\n\n- **AI 框架**：有基本搭建部署使用经验，包括 RAG、本地 Ollama\n- **图像生成**：有使用经验，包括 Stable Diffusion\n\n## 教育背景\n- **2010-2011**：巴黎第十三大学，网络多媒体策划与实践方向 CIWM\n  - 专注于网络多媒体内容的策划、设计和实践，包括但不限于网站设计、互动媒体和数字内容管理。\n- **2008-2010**：巴黎第十三大学，网络传媒专业 SRC\n  - 学习了网络传媒的基础知识，包括网络传播理论、数字媒体技术和传媒法规等。\n\n## 工作经历\n**法国部分**\n### 2012-2013\n- **公司**: sushikyo94.fr, Vadinoe.com\n- **职位**: 独立开发者\n- **项目**: 独立完成两个网店开发\n  - 使用 Opencart 完成一个网店开发\n  - 使用 Wordpress 完成另一个网店开发\n\n### 2013-2014\n- **公司**: Flashboutique\n- **职位**: 网店开发者\n- **项目**: Opencart 网店二次开发\n  - 包括轮盘游戏开发，基于开源代码\n\n### 2015-2017\n- **职位**: 全栈开发者\n- **项目**: 多个项目，包括工作和外包\n  - **Tokyo95.fr**\n    - 寿司店外卖 Magento 系统\n  - **Immo75.paris**\n    - 房地产租售信息平台网站 Wordpress 系统\n  - **Faguoyaodian.com**\n    - 法国药妆代售系统，Magento 系统\n  - **Aimu.fr**\n    - 中国寝具工厂法语网站，巴黎展会使用\n    - 备注：网站应该已经改版\n  - **Luxaword.com**\n    - 巴黎免税店在线商店\n    - 负责前端修改, SEO 优化和 Google 广告分析和优化\n\n**中国部分**\n### 2017-2019\n- **公司**: 微来（中国）有限公司\n- **职位**: 前端组长\n- **职责**:\n  - 负责技术选型\n  - 架构优化和框架维护\n  - 安排开发任务\n  - 实际参与项目最终实现\n- **项目**\n  - **澳蚁** app\n    - **项目描述**: 一款跨境电商保健品分销前后台\n    - **技术栈**: Vue + Node.js + Java\n    - **我的职责**:\n      - 负责 Vue 和 Node.js 开发\n      - 后用 UniApp 实现小程序、WebApp 和 iOS、Android App\n\n  - **砍砍猫**\n    - **项目描述**: 一款专注于砍价商品发布的小程序平台\n    - **技术栈**: UniApp\n    - **我的职责**:\n      - 使用 UniApp 实现小程序, nodejs 实现 websocket 和反向代理\n\n  - **小名片**\n    - **项目描述**: 一款无代码名片编辑生成小程序\n    - **技术栈**: UniApp\n    - **我的职责**:\n      - 使用 UniApp 实现小程序, nodejs 实现 websocket 和反向代理\n\n  - **winnet 微来中国官网**\n    - **项目描述**: 中法双语公司介绍\n    - **技术栈**: wordpress php\n\n## 个人项目\n\n### SQLite数据库备份工具\n[Gitee链接](https://gitee.com/imyyliang/sqlite-database-backup-tool)  \n一个自动备份SQLite数据库文件的解决方案，它提供了一个简单的Web界面，方便用户查看备份记录和管理数据库备份状态。该项目通过定时扫描和备份.db文件，确保数据的安全性和完整性。\n\n### Chrome 标签页AI分类插件\n[Gitee链接](https://gitee.com/imyyliang/tab-auto-group)  \n一款浏览器扩展程序，它通过采用本地AI大模型技术，如Ollama，自动为您的浏览器标签页进行智能分组，极大地提升了用户的浏览效率和体验。本插件不仅能够根据网页内容自动推荐合理的分组，还支持用户手动调整和管理标签，确保了灵活性和个性化。同时保护用户隐私，避免了将数据发送到外部服务器，从而无需依赖外部API密钥。\n\n### CLI Param Concat 命令参数拼接管理工具\n[GitHub链接](https://github.com/LiangWei88/cli-param-concat#readme)  \nCLI Param Concat 是一个基于 Node.js 开发的命令行参数管理工具，它通过读取文件中的参数并将其自动拼接到用户定义的命令中，简化了命令行参数的手动输入和管理。  \n该工具通过减少重复性任务和提高命令行操作的效率，帮助开发者更高效地执行复杂的命令行任务，同时避免了手动输入参数时可能出现的错误。\n\n### 码云贡献爬取工具\n**第二版:** [Gitee链接](https://gitee.com/imyyliang/gitee-contribute-scraper)  \n一个代码作业监控工具，它具有一个简洁的Web界面，允许教师输入学生的Gitee用户名。系统会自动收集每个学生的最近代码提交，并在网页上展示。此外，它还具备一个筛选功能，可以高亮显示那些在最近几天内没有提交代码的学生，使得教师能够迅速识别出哪些学生可能需要额外的关注或辅导。  \n**第一版:** [Gitee链接](https://gitee.com/imyyliang/code-checking)  \n一个自动化作业检查工具，它通过收集学生的Git仓库地址，自动爬取代码提交数据，并生成Markdown格式的报告，以便于教师快速查看和评估学生的代码提交情况。代码中包含了对GitHub和Gitee仓库的访问，以及对数据的格式化处理。\n\n### 作业提交系统\n[Gitee链接](https://gitee.com/imyyliang/homework-submission-system)  \n这是一个专为学生简历和自我介绍逐字稿设计的在线作业提交和批改平台。它允许教师通过简单的数据导入来管理学生作业，提供便捷的批改和反馈机制，帮助学生在求职前优化他们的简历和自我介绍。虽然最初计划包含更全面的班级和学生管理功能，但项目最终聚焦于核心的批改功能，以满足基本的教学需求。  \n\n### 井字棋\n[Gitee链接](https://gitee.com/imyyliang/tic-tac-toe)  \n为学生讲解JavaScript时编写的教学示例。它利用Vue框架快速搭建，旨在通过一个互动性强的游戏实例，帮助学生理解JavaScript在实际应用中的运用，同时加深他们对前端开发的理解。\n\n### 局域网评分投票工具\n[Gitee链接](https://gitee.com/imyyliang/lan-score)  \n修改自一个同事的代码, 一个基于Node.js的局域网评分投票工具，它允许学生在展示项目后，通过访问老师机器的IP地址来进行评分。这个工具不仅记录了每个参与者的评分，还计算并展示了去除最高分和最低分后的平均分，以及详细的评分记录。\n\n### Opencart 欧洲发票号修改插件\n[官网链接](https://www.opencart.com/index.php?route=marketplace/extension/info&member_token=9f4d2aa7c5ee7a444c7fc54d1b034053&extension_id=24685)  \nChange Invoice Number 是一个 OpenCart 扩展工具，它允许管理员在订单详情标签页手动输入和覆盖发票号码，增强了财务文件的定制和控制能力。这个插件是基于现有工具修改并修复了bug，经过OC 1.5.3.1和OC 1.5.6.1版本测试，它允许在发票生成后动态更改发票前缀和号码，并且修复了一个关键问题，确保发票前缀保留，以避免重新生成发票时出现编号冲突。\n\n### webpack-px2rem-loader\n[Github链接](https://github.com/LiangWei88/webpack-px2rem-loader)  \n一个实用的 webpack loader 优化版，它能够自动将 CSS 和 JS 中的像素值转换为 rem 单位，极大地简化了响应式设计的流程。它还修复了原插件中处理 media query 的 bug，确保了在不同屏幕尺寸下的兼容性。通过简单的配置，开发者可以轻松地在项目中实现像素到 rem 的转换，提高开发效率。\n\n### css 长度单位转换器\n[GitHub链接](https://github.com/LiangWei88/Design-size-convertor)  \n提供一个网页界面提交css文件, 能够智能地识别和转换CSS代码中的 px rem 等单位，支持等比转换和按比例转换，确保设计的一致性和准确性。这个工具不仅提高了前端开发的效率，还保证了在不同设计稿尺寸下的兼容性。\n\n### \"键盘侠\"\n[Gitee链接](https://gitee.com/imyyliang/jianpanxia)  \n一个键盘增强工具，它通过AutoHotKey脚本将Capslock键转变为Esc键，并赋予其vim风格的快捷键功能，极大提升了键盘的效率和灵活性。同时，它还扩展了数字键的快捷操作，通过Shift+Alt组合键快速输入数字，为无小键盘电脑日常编程和文本编辑带来便利。\n\n### AutoSiteScreenShot\n[Github链接](https://github.com/LiangWei88/AutoSiteScreenShot)  \n一个自动化网页截图工具，它能够针对单一网页在多种不同分辨率下生成截图，非常适合用于测试和验证网页在不同屏幕尺寸下的显示效果。这个工具简单易用，只需配置网址和分辨率，即可一键获取所需截图，极大地方便了网页设计的兼容性测试。\n\n### 简单 leetcode 题解\n[Github链接](https://github.com/LiangWei88/leetcode)  \n几年前摸鱼时候写的一些题目\n\n\n### Basscss 原子css\n[Gitee链接](https://gitee.com/imyyliang/basscss)  \nBasscss，一个轻量级的CSS工具库，提供无副作用的模块化样式，旨在提高开发速度和代码可读性。它以简洁和易用性为核心，是小型项目和个人开发者的理想选择，同时与Tailwind CSS和UnoCSS等流行库相比，提供了一个更为精简的原子类库解决方案。\n\n### 前端输入法词库\n[GitHub链接](https://github.com/LiangWei88/WebDevDictCN)  \nWebDevDictCN 是一个专为前端工程师和程序员设计的搜狗输入法词库，整合了1000+个与前端开发、编程和计算机相关的专业术语，旨在提高输入效率和准确性。它支持直接导入搜狗输入法，也兼容其他输入法，如讯飞，通过简单的编辑和导入操作即可使用。\n\n## 获得荣誉\n\n- **2018年** - 法律黑客松广州赛区亚军\n- **2019年** - 传智播客广州校区最佳新人\n- **2022年** - 传智播客广州校区优秀员工\n\n## 证书\n\n- 2008 年法语 B2\n- 软考中级软件设计师\n\n## 沟通语言\n\n- **法语**：熟练\n- **英语**：阅读熟练，口语一般\n- **普通话和粤语**：母语\n\n## 文章列表\n\n### [[2016]]\n- [[2016.如何在功能性和灵活性之间找到平衡？——以老版Wiz为知笔记为例]]\n- [[2016.谁动了我的硬盘？电脑数据容量单位科普入门浅析]]\n\n### [[2017]]\n- [[2017.WordPress 迁移后遇到的问题及解决方案]]\n- [[2017.如何合理定价建站服务？]]\n- [[2017.网站价值几何？]]\n- [[2017.网页设计定价：揭秘背后的故事]]\n\n### [[2023]]\n- [[2023.Vue-Admin-Work 运行时 Codemirror 错误解决方案]]\n- [[2023.前端 vue 基本功自测]]\n\n### [[2024]]\n- [[2024.ai读博客 Effective Prompt 编写高质量Prompt的14个有效方法]]\n- [[2024.Readme驱动开发（RDD）实践笔记]]\n- [[2024.个人笔记软件思考 - Obsidian vs logseq 和其他]]\n- [[2024.鸿蒙HarmonyOS开发高级认证知识点总结]]\n- [[2024.Docker镜像拉取困难？看这里！阿里云部署Dashy的成功案例]]\n- [[2024.打造高效的个人知识管理系统：我的思考与实践]]\n- [[2024.SQLite 数据库备份工具 README]]\n- [[2024.使用 AI 辅助开发阿里云 OSS 自动备份工具及监控功能]]\n[[2024.React 源码分析 - 第一部分架构说明]]\n\n# TODO 待编写介绍\n- 2018 法律黑客松广州赛区亚军\n- 断食记录小程序\n- github 状态\n- gitee 标签\n- npm 标签\n- 自己写的脚本油猴\n- youtube 总结工具本地大模型版本\n- [题库管理工具](https://gitee.com/imyyliang/question-bank-management)","n":0.049}}},{"i":2,"$":{"0":{"v":"Tags","n":1}}},{"i":3,"$":{"0":{"v":"鸿蒙","n":1}}},{"i":4,"$":{"0":{"v":"设计","n":1}}},{"i":5,"$":{"0":{"v":"科普","n":1}}},{"i":6,"$":{"0":{"v":"成长","n":1}}},{"i":7,"$":{"0":{"v":"思考","n":1}}},{"i":8,"$":{"0":{"v":"开发","n":1}}},{"i":9,"$":{"0":{"v":"前端","n":1}}},{"i":10,"$":{"0":{"v":"人工智能","n":1}}},{"i":11,"$":{"0":{"v":"Vue","n":1}}},{"i":12,"$":{"0":{"v":"Prompt","n":1},"1":{"v":"\n\n---\nid: kwngg0r05pzb8plwew0g2za\ntitle: ai读博客 Effective Prompt 编写高质量Prompt的14个有效方法\ndesc: ''\ntags: \n  - prompt\n  - 人工智能\n  - 科普\nupdated: 1729231177155\ncreated: 1729229940924\n---\n> 非原创, 用 ai 对笔记进行了重构\n\n# 如何撰写高效的提示词（Prompt Engineering）\n\n在人工智能领域，特别是与大型语言模型（LLMs）的交互中，提示词工程（Prompt Engineering）成为了一项重要的技能。本文旨在提供一套清晰的指导原则和实例，帮助用户撰写出更有效的提示词。\n\n## 1. 明确“好结果”的标准\n\n在设计提示词时，首先需要明确什么样的输出算是“好结果”。这是因为提示词的性能上限与我们对“好结果”的理解程度成正比。例如，如果任务是写影评，那么“好结果”可能包括深入的分析、流畅的文笔和精准的观点表达。\n\n**示例：**\n- Bad：请写一篇关于《长安三万里》的影评。\n- Good：请从画风和剧情两个角度，以专业的视角为《长安三万里》写一份通俗易懂的800字影评。\n\n## 2. 精准表达任务指令\n\n使用官方、书面、礼貌、友善的语言撰写提示词，力求语句流畅、意图清晰、表达精简。避免使用语法结构复杂、语义模糊、逻辑混乱的语言。\n\n**示例：**\n- Bad：解释提示工程的概念。解释要简短，几句话就行，不要描述得过于专业化。\n- Good：使用2-3句话向高中生解释提示工程的概念。\n\n## 3. 为否定句设置兜底策略\n\n当确实需要避免模型完成某些任务时，可以使用否定句，但应为每一个否定句都设置一个兜底策略。\n\n**示例：**\n- Bad：现在你是一个向客户推荐电影的客服。在此过程中，你不应该询问客户的兴趣和个人信息。\n- Good：现在你是一个向客户推荐电影的客服。在此过程中，你应该避免询问客户的兴趣和个人信息。如果你无法为客户推荐电影，你应该回答“抱歉，我无法为您推荐电影”。\n\n## 4. 指定模型所扮演的角色\n\n指定模型扮演的角色/身份可以帮助模型更好地定位答复的内容与风格。\n\n**示例：**\n- Bad：请帮我写一份能够吸引大量粉丝点赞的青岛旅游攻略。\n- Good：你是一位小红书爆款文案写作大师，请帮我写一份青岛旅游攻略。\n\n## 5. 指定生成结果的格式\n\n如果要进行的任务是信息处理类任务，则可显式规定模型返回结果的格式。\n\n**示例：**\n- 抽取出文本中提到的重要实体，包括人名、地名和机构名。\n  - 返回格式：\n    - **人名**：<人名列表，使用分号分隔>\n    - **地名**：<地名列表，使用分号分隔>\n    - **机构名**：<机构名列表，使用分号分隔>\n\n## 6. 增加强调词和强调符号\n\n当提示词包含的指令过多时，模型可能会更关心靠前和靠后的指令，忽略中间的指令。因此，将重要的需求放在前面，并在最后加以重复可以起到强调的作用。\n\n**示例：**\n- Bad：请抽取出以下简历的关键信息，并以json格式返回结果：{input}\n- Good：请抽取出以下简历的关键信息，并以json格式返回结果。\n  - 简历：\n    - \"{input}\"\n  - 你需要抽取的关键信息包括：\n    - \"1. 姓名\"\n    - \"2. 电话\"\n    - \"3. 毕业院校\"\n    - \"4. 科研经历\"\n    - \"5. 项目经历\"\n    - \"6. 荣誉奖项\"\n\n## 7. 撰写模块化的Prompt\n\n当提示词过长时，应将提示词划分成边界清晰的模块，任务描述、注意事项、样本示例、输入内容之间都应有明确的分隔符。\n\n**示例：**\n- Bad：请抽取出以下简历的关键信息，并以json格式返回结果：{input} 你需要抽取的关键信息包括：姓名、电话、毕业院校、科研经历、项目经历、荣誉奖项\n- Good：请抽取出以下简历的关键信息，并以json格式返回结果。\n  - 简历：\n    - \"\"\"\n    - {input}\n    - \"\"\"\n  - 你需要抽取的关键信息包括：\n    - \"\"\"\n    - 1. 姓名\n    - 2. 电话\n    - 3. 毕业院校\n    - 4. 科研经历\n    - 5. 项目经历\n    - 6. 荣誉奖项\n    - \"\"\"\n\n## 8. 在真实场景下迭代Prompt\n\n优质的提示词应具备良好的通用性，在不同的输入上有一致良好的表现。因此，Prompt的设计是一个迭代的过程，需要大量的实验来获得最佳效果。\n\n## 9. 测试Prompt的稳定性\n\n当任务的定义足够明确、清晰时，提示词的生成结果应该具备一定程度的稳定性，即多次生成的结果一致率要足够高。\n\n## 10. 使用思维链\n\n思维链可以促使模型将一个复杂的任务分解成一系列简单的任务，并逐个解决，最后汇总为最终的答案。\n\n**示例：**\n- Bad：$(1362+5145)*145-(1517*42+24)=?$\n- Good：请你帮我计算一下$(1362+5145)*145-(1517*42+24)=?$，每一步运算过程都要展示出来，并确保计算的正确性。\n\n## 11. 使用Few-shot Prompt\n\nFew-shot Prompt通过为模型提供一个答案的参考框架，通过模仿的方式来生成我们期望的结果。\n\n**示例：**\n- 请你判断以下问题是否属于知识问答类：\n  - 问题：世界上最高的建筑是什么 # easy case，属于客观知识问答\n  - 答案：是\n  - 问题：nested_dict = lambda: defaultdict(nested_dict) 如何理解这行代码 # corner case，属于代码问答\n  - 答案：否\n\n## 12. 设置拒答策略\n\n当模型无法提供准确答案时，设置拒答策略可以提高生成数据的质量。\n\n**示例：**\n- 只有当你知道答案或能够做出有根据的预测时，才能回答下面的问题，否则，请告诉我你不知道答案。\n\n## 13. 权衡Prompt的精度与召回率\n\n提示词表述越细致，越严格时，生成结果的精度越高，召回率越低。需要根据自身的业务需求，不断进行case分析与Prompt迭代，从而找到最优的Prompt表述策略。\n\n## 14. 使用大模型辅助Prompt撰写\n\n当任务本身比较模糊，难以准确且具体地描述时，可以向大模型寻求撰写提示词的灵感。\n\n**示例：**\n- 你现在是一个提示词生成专家，我想让ChatGPT完成{task}，请帮我写一份优质的提示词。\n\n## 最新提示词工程权威资讯链接\n\n以下是一些最新的提示词工程权威资讯链接，供您进一步学习和探索：\n\n- 自动提示词工程（APE）详细介绍和代码实现：[https://towardsdatascience.com/automated-prompt-engineering-the-definitive-hands-on-guide-1476c8cd3c50?gi=9b56727d992b](https://towardsdatascience.com/automated-prompt-engineering-the-definitive-hands-on-guide-1476c8cd3c50?gi=9b56727d992b) \n- 吴恩达联合OpenAI推出的免费ChatGPT提示词课程：[https://p.gptsb.cn/cn](https://p.gptsb.cn/cn) \n- Prompt Engineering课程中文版：[https://prompt-engineering.xiniushu.com/](https://prompt-engineering.xiniushu.com/) \n- PromptPerfect：专为大型语言模型设计的提示优化器：[https://promptperfect.jina.ai/](https://promptperfect.jina.ai/) \n- AIShort：提供多种语言模型的提示词生成和优化：[https://aishort.nextai.today/](https://aishort.nextai.today/) \n- 吴恩达ChatGPT提示词课程中文完整版视频：[https://www.bilibili.com/video/BV1LL41167hW/](https://www.bilibili.com/video/BV1LL41167hW/) \n- 吴恩达官宣的ChatGPT提示词新课：[https://www.thepaper.cn/newsDetail_forward_22895559?commTag=true](https://www.thepaper.cn/newsDetail_forward_22895559?commTag=true) \n- 百度文心大模型ERNIE的最新进展：[https://baike.baidu.com/item/%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/62642976](https://baike.baidu.com/item/%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/62642976)","n":0.076}}},{"i":13,"$":{"0":{"v":"React","n":1}}},{"i":14,"$":{"0":{"v":"2024 年文章","n":0.707}}},{"i":15,"$":{"0":{"v":"鸿蒙HarmonyOS开发高级认证知识点总结","n":1},"1":{"v":"## 应用架构的演进\n- **单体架构**：早期的应用开发模式，所有功能集成在一个应用内，部署和维护相对简单，但随着应用复杂度增加，其缺点逐渐显现，如难以扩展、部署缓慢等。\n- **微服务架构**：将单体应用拆分为多个独立的服务，每个服务负责一部分业务功能，服务间通过轻量级通信协议进行交互。这种架构提高了系统的可扩展性和可维护性。\n- **Serverless架构**：一种更进一步的架构模式，开发者无需关心服务器的管理，只需编写代码，由云服务商负责运行环境的搭建、扩缩容等，进一步降低了运维成本。\n\n## ArkUI与声明式开发\n### ArkTS 开发范式\n- **ArkTS**：是鸿蒙操作系统中的一种开发语言，基于TypeScript，为鸿蒙应用提供了一种高效的开发方式。它允许开发者使用TypeScript的语言特性来编写鸿蒙应用，同时享受鸿蒙操作系统提供的强大的开发框架和组件。\n\n### ArKUI声明式开发范式\n- **基本组成**：包括装饰器、自定义组件、UI描述、内置组件、属性方法、事件方法等。\n- **ArkUI声明式开发**：ArkUI是鸿蒙操作系统的声明式UI开发范式，它允许开发者通过声明式的方法来构建用户界面。\n- **ArkTS声明式开发组成**：包括装饰器、自定义组件、UI描述、内置组件、属性方法、事件方法。\n- **状态数据触发方法**：@state修饰的状态数据被修改时会触发组件的build方法进行UI界面更新。\n- **state状态数据特征**：@State变量必须给定初始值，否则编译器无法推断其类型。\n\n## 配置与管理\n### 版本管理\n- **版本发布**：在软件开发中，发布版本是一个重要的过程。一旦版本发布，该版本的代码将被冻结，不可再进行更改。这是为了确保生产环境中的稳定性和可预测性。\n- **版本迭代**：新功能的添加和bug的修复通常在新版本中进行。开发者可以在新版本中进行更改，并通过发布新版本来更新应用。\n- **云函数触发器**：云函数在打包前，创建对应的触发器。\n- **端云一体化开发**：使用端云一体化开发，开发者无需自己搭建服务器，并进行运维，因为云服务提供了后端服务的托管和运维。\n- **端云一体化费用**：并不是所有使用端云一体化的云端资源都需要支付费用，有些服务可能有免费额度或免费层。\n- **页面路径配置**：在`main_pages.json`文件中可以设置页面的路径配置信息。\n- **ohpm三方库依赖**：引用ohpm（OpenHarmony Package Manager）三方库的包依赖是在`oh-package.json5`配置文件中设置的。\n- **应用包名与`config.json`**：创建应用时，应用包名需要和`config.json`文件中的`bundleName`字段保持一致。\n- **应用或元服务软件包格式**：上传鸿蒙应用或元服务软件包时，软件包的格式是`.app`。\n- **应用包名规范**：应用包名不能包含系统保留字段，如`.system.`、`.harmony.`、`.ohos`等，应采用反域名形式。其他如 `test` 之类可以\n\n### 鸿蒙应用/元服务上架问题\n- 包括软件包中的发布Profile文件和当前上传软件包的应用不匹配、软件包中的发布证书与发布Profile文件中的发布证书不匹配、软件包未签名导致提示非法软件包、软件包中使用证书已经失效或过期。\n\n## 兼容性与特征能力\n### 认证服务\n- **手机号码登录**：认证服务提供了多种登录方式，包括手机号码登录。在进行手机号码登录时，需要填写正确的国家码以确保短信验证码等能够正确发送到用户手机。86-189****1234\n- **权限控制**：认证服务还提供了用户身份验证和授权管理功能，是数据访问权限控制的基础。通过认证服务，可以确保只有授权用户才能访问特定的数据和服务。\n- **HarmonyOS兼容性**：HarmonyOS应用可以兼容OpenHarmony生态，这意味着开发者可以为不同的鸿蒙版本开发应用。\n- **鸿蒙特征能力**：跨端迁移和协同是鸿蒙特征的能力之一，属于“统一生态”特征。\n- **鸿蒙特征场景化能力**：包括一次开发、多端部署、可分可合、自由流转、统一生态、原生智能。\n- **一次开发多端部署层次**：包括界面级-多、功能级-多、工程级-多。\n- **华为账号认证**：认证服务支持华为账号认证。\n\n## 测试与发布流程\n### Serverless服务\n- **云函数**：Serverless服务的一种，允许开发者编写和部署代码而无需管理服务器。云函数按实际使用计费，具有弹性伸缩和免运维的特点。\n- **云数据库和云存储**：提供了数据存储和访问的能力，也是Serverless服务的一部分。它们可以根据实际使用情况进行自动扩缩容，简化了数据管理。\n- **鸿蒙应用获取**：发布后的鸿蒙应用可以在华为应用市场获取。\n- **开放式测试体验**：受邀测试用户可以通过进入服务中心，打开“开发者测试”开关，在最下方的“服务测试”找到待体验的元服务。\n- **追加测试用户**：发布开放式测试版本后，可以手动添加追加用户。\n- **开放式测试版本审核**：发布开放式测试版本后，不需要人工审核。\n- **元服务测试用户列表**：元服务创建测试用户时，用户列表存储位置需要选择，例如选择地区“中国”。\n- **开放式测试版本时间限制**：开放式测试版本的测试时间是有限制的，具体时长需根据开发者在发布时设置。\n- **追加测试用户流程**：发布开放式测试版本后，开发者可直接在当前版本追加新的测试用户，并通过系统发送邀请。\n- **发布应用Profile类型**：发布HarmonyOS应用时，需要创建的Profile类型是发布类型。\n\n## 线程与后台任务处理\n### Worker线程\n- **worker线程**：worker线程是用于执行后台任务的，它不支持UI操作，因为它是在一个没有UI上下文的环境中运行的。\n- **Worker线程与UI操作**：Worker线程不支持UI操作，主要用于执行耗时操作，以避免阻塞UI线程。UI更新需通过与UI线程的通信实现。\n- **Worker线程数量限制**：Worker线程的最大同时激活数为8，以确保系统资源的合理分配和有效管理。\n\n## 通信协议与数据管理\n### 云函数包格式\n- **.zip包**：云函数的部署包通常是以.zip格式提供的压缩包，包含了函数的代码、依赖库以及其他必要的配置文件。\n- **WebSocket协议**：模块提供的全双工通信协议是WebSocket。\n- **首选项存储**：首选项（Preferences）是一种轻量级的存储解决方案，用于存储应用的设置信息。在鸿蒙中，首选项的Key是唯一的，不能重复。\n- **首选项数据库特性**：首选项是非关系数据库，它不支持ACID特性，因为它主要用于存储简单的键值对数据。\n- **HAP包大小**：元服务包由一个或多个HAP包组成，每个HAP包不得超过10MB，以提供秒开体验。\n- **端云一体化开发**：端云一体化开发允许开发者无需自建服务器和进行运维，利用华为云提供的Serverless服务进行应用开发。\n\n### 服务\n- **认证服务**：支持华为账号认证。\n- **公共事件服务**：提供订阅、发布和取消订阅公共事件的能力。\n- **加密**：HUKS的中文全称是“通用秘钥库系统”。\n- **WebView**：HarmonyOS提供的WebView支持与H5双向通信。\n\n## 端云一体化开发\n### 端云一体化\n- **优势**：端云一体化开发允许开发者在一个工程内同时开发端侧和云侧代码，降低了后端开发的门槛。云侧基于Serverless构建，具有弹性伸缩和免运维的优势。此外，HarmonyOS的DevEco Studio提供了强大的开发工具支持。\n- **开发语言**：端云一体化开发中，前后端都可以使用TypeScript，无需精通多种语言。\n- **DevEco Studio实现端云一体化**：通过工程模板来实现。\n- **支持的最低鸿蒙API版本**：端云一体化支持的最低API版本是9。\n- **工程目录结构**：分为端开发工程Application、云开发工程CloudProgram、端侧公共库Extrernal Libraries。\n- **集成的服务SDK**：包括云函数、云数据库、云存储。\n- **云函数调用**：云函数触发器创建时机应在云函数打包之前创建对应函数的触发器。\n- **云端资源**：使用端云一体化的云端资源不一定需要支付费用，存在免费档套餐。\n\n## 组件开发\n### 页面栈\n- **页面栈数量**：每调用一次`router.pushUrl()`方法，默认情况下，页面栈数量会增加1。鸿蒙系统对页面栈的数量有限制，通常是32个。\n- **页面跳转销毁**：`router.replaceUrl()`方法可以跳转到一个新页面，并销毁当前页面。\n\n### Tab组件页签\n- **Tabs组件页签位置**：当`barPosition`为`End`，`vertical`属性为`true`时，页签位于容器右侧，而不是底部。\n\n### Column和Row容器组件\n- **子组件对齐**：`alignItems`用于设置子组件在交叉轴方向上的对齐格式，而`justifyContent`用于设置子组件在主轴方向上的对齐格式。\n\n### 自定义组件和子组件\n- **生命周期**：每个自定义组件都有自己的生命周期，但并非所有生命周期函数都对所有组件有效。\n- **自定义组件生命周期**：每一个自定义组件`@Component`都有自己的生命周期，但注意 `Page` 相关的周期只有 `@Entry` 的页面入口有。\n- **自定义组件生命周期时机**：`aboutToAppear()`在`build`函数之前执行。用于组件显示前的准备工作。\n- **父子组件双向数据绑定**：使用 `@State` 和 `@Link` 进行数据双向绑定。\n\n### Video组件\n- **回调事件**：`onPrepared`事件用于在视频准备完成时获取视频时长。容易混淆的是`onStart`视频播放时触发该事件，但在这里无法获取视频时长。\n\n### 组件化特点\n- **特点**：自定义组件的组件化特点包括可组合、可重用、配置化生命周期。数据驱动更新。\n\n### 容器组件滚动\n- **可滚动组件**：`Scroll`、`List`、`Grid`等容器组件可以滚动。\n\n### 组件层次结构\n- **层次结构正确性**：正确的层次结构应符合父子组件的嵌套关系。\n- **正确的层次结构包括**：`Text>Span`、`Button>Column>Image`、`Column>Row>Button`。\n\n## 其他\n- **鸿蒙应用获取渠道**：发布后的鸿蒙应用可以在华为应用市场获取。\n- **帐号认证方式**：HarmonyOS认证服务支持华为帐号。\n- **UIAbility启动模式**：`muliton`为多实例模式，每次`startAbility`都会启动一个新的实例，但系统默认启动模式为`singleton`。\n- **证书类型**：发布应用时要创建证书，证书类型应选择“发布证书”。\n- **公共事件服务能力**：包括订阅公共事件、发布公共事件、取消订阅公共事件。注意,没有取消发布, 都发出去了怎么取消。\n- **端云一体化集成服务SDK**：包括云函数、云数据库、云存储。注意没有云托管。\n- **端云一体化云函数操作**：包括编写函数、测试函数、打包函数、部署函数。\n- **UIAbility生命周期函数**：包括`onCreate`、`onForeground`、`onBackground`、`onDestroy`。\n- **开放式测试体验**：受邀测试用户需点击邀请链接接受邀请，然后跳转到应用市场或搜索待体验的元服务名称进行体验。\n- **软件包格式**：鸿蒙应用或元服务软件包的格式为`.app`，由一个或多个HAP和描述每个HAP属性的`pack.info`组成。注意区别云函数是 `zip`。\n- **Profile文件的必要性**：一个完整的软件包需要有一个Profile文件，用于描述应用的配置信息，如包名、版本号、设备类型等。\n- **开放式测试版本时间限制**：开放式测试版本的测试时间是有限制的，具体时长需根据开发者在发布时设置。\n- **组件子组件包含**：`LoadingProgress`组件通常不包含子组件，而`Button`、`Text`和`Row`等组件可以包含其他子组件。\n- **ohpm三方库依赖配置**：引用ohpm三方库的包依赖在`oh-package.json5`配置文件中设置。\n- **module.json5配置信息**：`module.json5`中包含Ability的配置信息、设备类型信息和应用权限申请列表。注意应用名和应用版本不在这里而在 `app.json`。","n":0.086}}},{"i":16,"$":{"0":{"v":"打造高效的个人知识管理系统：我的思考与实践","n":1},"1":{"v":"在这个信息爆炸的时代，个人知识管理已经成为了提升工作效率和学习效率的关键。今天，我想和大家分享一下我是如何构建我的个人知识管理系统的，以及在这个过程中的一些思考和决策。\n\n## 个人数据收集与管理：基础框架\n\n我的个人知识管理系统的基石是碎片化数据的初步收集。我使用备忘录（memos）作为工具，快速记录下任何即时的想法和信息，这些碎片化的数据构成了我的个人大数据的基础。\n\n## 数据信息管理：分类与工具\n\n在数据信息管理方面，我将数据分为两大类：列表型数据和表格数据库型数据。\n\n### 列表型数据：Trilium的高效管理\n\n对于需要形成列表的数据，如喜欢的软件、潜在的文章主题、AI提示词集合等，我选择使用Trilium进行管理。Trilium的跨平台访问特性使得数据管理变得异常便捷。\n\n### 表格数据库型数据：Anytype的强大功能\n\n对于那些需要以表格或数据库形式存储和处理的数据，如餐厅评分、联系人及其联系方式等，Anytype成为了我的首选。Anytype提供了强大的数据组织和处理功能，极大地提升了我的数据处理效率。\n\n## 个人知识笔记管理：Obsidian的深度整合\n\n在个人知识笔记管理方面，我选择了Obsidian。这款工具不仅支持日记记录和深度知识输出，还具备强大的功能，如插件支持、代码显示和双链等。尽管同步过程相对复杂，但其优势远远超过了这一限制。\n\n## 工具对比与决策：结合使用的优势\n\n在Obsidian和Trilium之间，我进行了深入的对比。Obsidian在美观、标签管理和双链管理方面更胜一筹，但需要在本机使用，这在临时查询时可能不太方便，同时也存在隐私问题。而Trilium则提供了服务器端的网页版，可以随时访问，但在双链和Markdown支持方面稍显不足。\n\n最终，我决定将这两款工具结合起来使用，以充分利用它们各自的优势，避免简单列表与深度知识的混淆。\n\n## 未来规划：持续优化与调整\n\n我的个人知识管理系统仍在不断完善中。我计划继续使用备忘录进行一元化记录，并根据需要进行深度加工和分类。同时，我也会根据使用经验的积累，持续思考、感受并调整我的个人数据和知识管理系统。\n\n通过这一系列的思考和实践，我的个人知识管理系统已经逐渐成型。这一体系旨在灵活应对不同信息类型的需求，同时不断优化使用体验，以提升我的学习和工作效率。未来的变化仍需观察和适应，但我相信，通过不断的努力和调整，我能够打造出一个更加高效和个性化的知识管理系统。\n\n---\n\n希望我的分享能够给大家带来一些启发，如果你有任何关于个人知识管理的想法或经验，也欢迎在评论区和我交流！让我们一起在这个信息时代中，更高效地管理我们的知识和数据。\n","n":0.354}}},{"i":17,"$":{"0":{"v":"使用 AI 辅助开发阿里云 OSS 自动备份工具及监控功能","n":0.447},"1":{"v":"\n## 相关资源\n- [项目地址](https://gitee.com/imyyliang/sqlite-database-backup-tool)\n- README文件内容: [[2024.SQLite 数据库备份工具 README]]\n\n## 前言\n作为一名前端工程师，我经常自托管一些服务，比如笔记和待办事项等，这些服务通常使用 sqlite 数据库。为了确保数据的安全性，我决定开发一个备份工具。在这个过程中，我充分利用了 AI 工具 aider，结合自己的专业知识，仅用三个半小时就实现了一个功能较为完善的备份工具，其中还包括了一个监控功能。下面我将详细介绍整个开发过程。\n## 一、开发背景\n我自托管了不少服务，数据都存储在 sqlite 数据库中。为了防止数据丢失，需要一个备份工具。然而，我发现现有的备份工具都比较折腾，于是决定自己动手开发一个。\n## 二、技术选型\n- 编程语言：选择 Node.js，因为它具有强大的文件操作和网络编程能力。\n- 进程管理工具：使用 pm2 来维护执行，确保程序的稳定性和可靠性。\n- AI 辅助工具：aider，用于生成代码和提供思路。\n- 云存储服务：阿里云 OSS，提供可靠的存储和备份解决方案。\n- 定时任务包：node-cron，用于实现定时备份功能。\n## 三、开发过程\n### （一）链接阿里云 OSS\n首先，让 AI 写一个链接阿里云 OSS 的代码。阿里云 OSS 提供了丰富的 API，可以方便地进行文件上传和下载等操作。通过以下步骤实现了链接阿里云 OSS：\n自己开通一个 OSS 服务，获取名称、区域和 accessKey 等信息。\n测试 AI 生成的代码，确保能够成功连接到阿里云 OSS。\n### （二）遍历并上传 db 文件\n接着，让 AI 写一段代码，遍历当前目录下的所有 db 文件，并上传到阿里云 OSS。这个功能可以确保所有的 sqlite 数据库文件都能被备份到云端。\n###（三）定时备份功能\n为了实现定时备份，使用了 node-cron 包。这个包可以方便地设置定时任务，实现每两个小时上传一次备份的功能。这是作为程序员使用 AI 的优势之一，因为普通人可能不知道这个包，而 AI 在生成代码时可以根据程序员的提示使用合适的工具。\n### （四）备份记录\n让 AI 写一段代码，在每次备份的时候，在当前目录下的 backup-log 文件里面留下一条备份记录，包括备份时间、备份成功的文件数量和备份失败的文件数量，用中文记录。这样可以方便地查看备份的历史记录，以及了解备份的情况。\n### （五）重构代码\n虽然 AI 生成的代码已经能够实现基本的功能，但是代码的结构和注释可能不够清晰。由于代码太长，我决定自己处理重构和添加注释的工作。通过重构代码，可以提高代码的可读性和可维护性。\n### （六）监控功能\n为了实时了解备份的情况，我决定添加一个监控功能。将备份功能手动拆成一个独立模块，然后让 AI 写一个服务器，每次访问都会返回备份记录的最后一行，然后作为模块导出。最后，在主文件中引入这两个模块，就实现了我想要的功能。这个监控功能我是作为 iframe 嵌入到我自己的仪表板主页中的，方便随时查看备份情况。\n## 四、总结\n通过这次开发，我深刻体会到了 AI 辅助开发的优势。虽然 AI 目前还不能完全独立地完成一个复杂的项目，但是它可以为程序员提供很多帮助，比如生成代码、提供思路和解决问题等。在未来的开发中，我将继续探索如何更好地利用 AI 工具，提高开发效率和质量。\n总的来说，这个备份工具的开发过程虽然花费了一些时间，但是相比自己完全手动开发，还是节省了很多时间。希望我的经验能够对其他程序员有所帮助。","n":0.111}}},{"i":18,"$":{"0":{"v":"个人笔记软件思考 - Obsidian vs logseq 和其他","n":0.408},"1":{"v":"### 个人笔记软件使用体验与比较\n\n在寻找合适的笔记软件过程中，我经历了多次尝试，从 Obsidian 到 Logseq，再到其他多种选择，最终形成了一些对笔记工具的深刻见解。以下是我对几款主要笔记软件的比较，以及我在选择过程中所考虑的各种因素。\n\n#### 1. 笔记软件使用的探索过程\n\n我的笔记软件探索旅程始于 Obsidian，这是一款备受推崇的工具，但在使用中我发现 iCloud 同步经常出现冲突，导致使用体验不佳。随后，我试用了 Logseq，虽然其线性结构引起了我的关注，但随着笔记数量的增加，我开始担心无法有效管理和检索信息。接着，我尝试了其他工具，如 Anything 和自建服务器的方式，逐渐对各种软件有了更深入的了解。\n\n#### 2. 自有数据笔记工具对比\n\n我总结了以下几款笔记工具的特点，供未来的选择参考：\n\n| 功能 \\\\ 软件 | Trilium | Logseq | Obsidian | Silver Bullet | Anytype | TiddlyWiki |\n| --- | --- | --- | --- | --- | --- | --- |\n| 文件夹系统 | ●   |     |     |     | ●   | ●   |\n| 标签系统 | ●   | ●   | ●   |     | ●   | ●   |\n| 日期系统 | ●   | ●   | ●   | ●   | ●   | ●   |\n| Markdown 语法 | ●   | ●   | ●   | 部分 | ●   |     |\n| 全文搜索 | ●   | ●   | ●   | ●   |     | ●   |\n| 文档导出 |     |     |     |     | ●   | ●   |\n| 文档导入 |     |     |     |     |     |     |\n| 文档版本 | ●   |     |     |     |     |     |\n| 链接跳转 | ●   | ●   | ●   | ●   | ●   | ●   |\n| 反向链接 | ●   | ●   | ●   | ●   | ●   |     |\n| 大纲式编辑 |     | ●   |     | ●   |     |     |\n| 跨平台同步 | ●   | ○   | ○   |     | ●   | ●   |\n| 表格批量编辑 |     | ●   | ●   | ●   |     |     |\n| 代码查询 |     | ●   |     | ●   |     |     |\n| 代码高亮 |     | ●   | ●   | ●   | ●   | ●   |\n| 层级折叠 |     | ●   |     | ●   |     |     |\n| 流程图 | ●   |     |     |     |     | ●   |\n| 多颜色主题 |     |     |     |     | ●   | ●   |\n| 易用性 |     |     |     |     | ●   | ○   |\n\n#### 3. 反思与选择的原因\n\n在对比各软件的过程中，我最终选择了 Obsidian，主要基于以下几点考虑：\n\n- **Logseq 的线性结构问题**：Logseq 强调线性记录，但随着笔记的增加，容易产生混乱和焦虑感。我担心数据检索的准确性，因为它依赖于严格的格式一致性。\n  \n- **Obsidian 的灵活性**：Obsidian 提供更灵活的文件归档方式，可以有效地管理长期笔记，避免了 Logseq 的线性结构带来的心理负担。\n\n- **长期记录的优势**：Obsidian 允许我通过文件夹和标签系统有效整理笔记，这种结构更符合我长期使用的需求。\n\n#### 4. 软件的优缺点总结\n\n**Logseq**：\n- 优点：适合短期项目，支持大纲和块引用。\n- 缺点：线性结构不适合长期笔记管理，可能导致心理负担。\n\n**Obsidian**：\n- 优点：灵活的文件管理和长期记录能力。\n- 缺点：对于一些快速记录需求可能不够便捷。\n\n#### 5. 下一步的建议\n\n为了优化我的笔记管理系统，我计划：\n\n1. **建立定期整理的习惯**：即使 Obsidian 支持灵活的归档和整理方式，定期回顾和整理笔记仍然是保持系统清晰的关键。\n\n2. **探索插件生态**：利用 Obsidian 的丰富插件，增强笔记管理的功能，特别是在自动化整理和日常任务管理方面。\n\n3. **明确笔记分类**：为不同类型的笔记设定分类策略，以确保信息管理的高效性，避免混乱。\n\n### 总结\n\n经过多次尝试与反思，我认为 Obsidian 更加适合我的长期笔记需求，而 Logseq 可作为短期项目的辅助工具。这一过程不仅让我找到了一款理想的笔记软件，也让我认识到整理与分类的重要性。未来，我将继续探索与实践，以不断优化我的笔记管理系统。","n":0.058}}},{"i":19,"$":{"0":{"v":"ai读博客 Effective Prompt 编写高质量Prompt的14个有效方法","n":0.5},"1":{"v":"> 非原创, 用 ai 对笔记进行了重构\n\n# 如何撰写高效的提示词（Prompt Engineering）\n\n在人工智能领域，特别是与大型语言模型（LLMs）的交互中，提示词工程（Prompt Engineering）成为了一项重要的技能。本文旨在提供一套清晰的指导原则和实例，帮助用户撰写出更有效的提示词。\n\n## 1. 明确“好结果”的标准\n\n在设计提示词时，首先需要明确什么样的输出算是“好结果”。这是因为提示词的性能上限与我们对“好结果”的理解程度成正比。例如，如果任务是写影评，那么“好结果”可能包括深入的分析、流畅的文笔和精准的观点表达。\n\n**示例：**\n- Bad：请写一篇关于《长安三万里》的影评。\n- Good：请从画风和剧情两个角度，以专业的视角为《长安三万里》写一份通俗易懂的800字影评。\n\n## 2. 精准表达任务指令\n\n使用官方、书面、礼貌、友善的语言撰写提示词，力求语句流畅、意图清晰、表达精简。避免使用语法结构复杂、语义模糊、逻辑混乱的语言。\n\n**示例：**\n- Bad：解释提示工程的概念。解释要简短，几句话就行，不要描述得过于专业化。\n- Good：使用2-3句话向高中生解释提示工程的概念。\n\n## 3. 为否定句设置兜底策略\n\n当确实需要避免模型完成某些任务时，可以使用否定句，但应为每一个否定句都设置一个兜底策略。\n\n**示例：**\n- Bad：现在你是一个向客户推荐电影的客服。在此过程中，你不应该询问客户的兴趣和个人信息。\n- Good：现在你是一个向客户推荐电影的客服。在此过程中，你应该避免询问客户的兴趣和个人信息。如果你无法为客户推荐电影，你应该回答“抱歉，我无法为您推荐电影”。\n\n## 4. 指定模型所扮演的角色\n\n指定模型扮演的角色/身份可以帮助模型更好地定位答复的内容与风格。\n\n**示例：**\n- Bad：请帮我写一份能够吸引大量粉丝点赞的青岛旅游攻略。\n- Good：你是一位小红书爆款文案写作大师，请帮我写一份青岛旅游攻略。\n\n## 5. 指定生成结果的格式\n\n如果要进行的任务是信息处理类任务，则可显式规定模型返回结果的格式。\n\n**示例：**\n- 抽取出文本中提到的重要实体，包括人名、地名和机构名。\n  - 返回格式：\n    - **人名**：<人名列表，使用分号分隔>\n    - **地名**：<地名列表，使用分号分隔>\n    - **机构名**：<机构名列表，使用分号分隔>\n\n## 6. 增加强调词和强调符号\n\n当提示词包含的指令过多时，模型可能会更关心靠前和靠后的指令，忽略中间的指令。因此，将重要的需求放在前面，并在最后加以重复可以起到强调的作用。\n\n**示例：**\n- Bad：请抽取出以下简历的关键信息，并以json格式返回结果：{input}\n- Good：请抽取出以下简历的关键信息，并以json格式返回结果。\n  - 简历：\n    - \"{input}\"\n  - 你需要抽取的关键信息包括：\n    - \"1. 姓名\"\n    - \"2. 电话\"\n    - \"3. 毕业院校\"\n    - \"4. 科研经历\"\n    - \"5. 项目经历\"\n    - \"6. 荣誉奖项\"\n\n## 7. 撰写模块化的Prompt\n\n当提示词过长时，应将提示词划分成边界清晰的模块，任务描述、注意事项、样本示例、输入内容之间都应有明确的分隔符。\n\n**示例：**\n- Bad：请抽取出以下简历的关键信息，并以json格式返回结果：{input} 你需要抽取的关键信息包括：姓名、电话、毕业院校、科研经历、项目经历、荣誉奖项\n- Good：请抽取出以下简历的关键信息，并以json格式返回结果。\n  - 简历：\n    - \"\"\"\n    - {input}\n    - \"\"\"\n  - 你需要抽取的关键信息包括：\n    - \"\"\"\n    - 1. 姓名\n    - 2. 电话\n    - 3. 毕业院校\n    - 4. 科研经历\n    - 5. 项目经历\n    - 6. 荣誉奖项\n    - \"\"\"\n\n## 8. 在真实场景下迭代Prompt\n\n优质的提示词应具备良好的通用性，在不同的输入上有一致良好的表现。因此，Prompt的设计是一个迭代的过程，需要大量的实验来获得最佳效果。\n\n## 9. 测试Prompt的稳定性\n\n当任务的定义足够明确、清晰时，提示词的生成结果应该具备一定程度的稳定性，即多次生成的结果一致率要足够高。\n\n## 10. 使用思维链\n\n思维链可以促使模型将一个复杂的任务分解成一系列简单的任务，并逐个解决，最后汇总为最终的答案。\n\n**示例：**\n- Bad：$(1362+5145)*145-(1517*42+24)=?$\n- Good：请你帮我计算一下$(1362+5145)*145-(1517*42+24)=?$，每一步运算过程都要展示出来，并确保计算的正确性。\n\n## 11. 使用Few-shot Prompt\n\nFew-shot Prompt通过为模型提供一个答案的参考框架，通过模仿的方式来生成我们期望的结果。\n\n**示例：**\n- 请你判断以下问题是否属于知识问答类：\n  - 问题：世界上最高的建筑是什么 # easy case，属于客观知识问答\n  - 答案：是\n  - 问题：nested_dict = lambda: defaultdict(nested_dict) 如何理解这行代码 # corner case，属于代码问答\n  - 答案：否\n\n## 12. 设置拒答策略\n\n当模型无法提供准确答案时，设置拒答策略可以提高生成数据的质量。\n\n**示例：**\n- 只有当你知道答案或能够做出有根据的预测时，才能回答下面的问题，否则，请告诉我你不知道答案。\n\n## 13. 权衡Prompt的精度与召回率\n\n提示词表述越细致，越严格时，生成结果的精度越高，召回率越低。需要根据自身的业务需求，不断进行case分析与Prompt迭代，从而找到最优的Prompt表述策略。\n\n## 14. 使用大模型辅助Prompt撰写\n\n当任务本身比较模糊，难以准确且具体地描述时，可以向大模型寻求撰写提示词的灵感。\n\n**示例：**\n- 你现在是一个提示词生成专家，我想让ChatGPT完成{task}，请帮我写一份优质的提示词。\n\n## 最新提示词工程权威资讯链接\n\n以下是一些最新的提示词工程权威资讯链接，供您进一步学习和探索：\n\n- 自动提示词工程（APE）详细介绍和代码实现：[https://towardsdatascience.com/automated-prompt-engineering-the-definitive-hands-on-guide-1476c8cd3c50?gi=9b56727d992b](https://towardsdatascience.com/automated-prompt-engineering-the-definitive-hands-on-guide-1476c8cd3c50?gi=9b56727d992b) \n- 吴恩达联合OpenAI推出的免费ChatGPT提示词课程：[https://p.gptsb.cn/cn](https://p.gptsb.cn/cn) \n- Prompt Engineering课程中文版：[https://prompt-engineering.xiniushu.com/](https://prompt-engineering.xiniushu.com/) \n- PromptPerfect：专为大型语言模型设计的提示优化器：[https://promptperfect.jina.ai/](https://promptperfect.jina.ai/) \n- AIShort：提供多种语言模型的提示词生成和优化：[https://aishort.nextai.today/](https://aishort.nextai.today/) \n- 吴恩达ChatGPT提示词课程中文完整版视频：[https://www.bilibili.com/video/BV1LL41167hW/](https://www.bilibili.com/video/BV1LL41167hW/) \n- 吴恩达官宣的ChatGPT提示词新课：[https://www.thepaper.cn/newsDetail_forward_22895559?commTag=true](https://www.thepaper.cn/newsDetail_forward_22895559?commTag=true) \n- 百度文心大模型ERNIE的最新进展：[https://baike.baidu.com/item/%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/62642976](https://baike.baidu.com/item/%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/62642976) \n","n":0.08}}},{"i":20,"$":{"0":{"v":"SQLite 数据库备份工具 README","n":0.577},"1":{"v":"## 相关资源\n- 开发记录: [[2024.使用 AI 辅助开发阿里云 OSS 自动备份工具及监控功能]]\n- [项目地址](https://gitee.com/imyyliang/sqlite-database-backup-tool)\n\n## 项目简介\n----\n\n本项目旨在自动备份当前目录下所有 `.db` SQLite 数据库文件，并提供一个简单的 Web 服务来查看最后一条备份记录。该项目适用于需要定期备份 SQLite 数据库的场景，并希望通过 Web 界面快速查看备份状态的用户。\n\n## 功能特点\n----\n\n*   **自动备份**：每两小时自动扫描并备份当前目录及其子目录下的所有 `.db` 文件。\n*   **Web 访问**：提供一个简单的 Web 服务，通过访问 `http://localhost:4783` 可以查看最后一条备份记录。\n*   **日志记录**：每次备份操作都会记录到 `backup-log` 文件中，方便后续查看备份历史。\n\n## 使用方法\n----\n\n### 安装依赖\n\n首先，确保你已经安装了 Node.js 和 npm。然后，在项目根目录下运行以下命令安装依赖：\n\n```text-plain\nnpm install\n```\n\n### 启动服务\n\n安装完成后，运行以下命令启动备份服务和 Web 服务：\n\n```text-plain\nnode index.js\n```\n\n### 查看备份记录\n\n启动服务后，打开浏览器访问 `http://localhost:4783`，即可查看最后一条备份记录。\n\n## 项目结构\n----\n\n*   `server.js`：提供 Web 服务，展示最后一条备份记录。\n*   `backupUtil.js`：负责自动备份 `.db` 文件，并记录备份日志。\n*   `index.js`：启动备份服务和 Web 服务。\n*   `config.json`：配置文件，包含阿里云 OSS 的访问密钥等信息。\n\n## 贡献\n--\n\n欢迎大家贡献代码，提出问题或建议。如果你觉得这个项目对你有帮助，请点个 star 支持一下！\n\n## 许可证\n---\n\n本项目采用 WTFPL 许可证，\n\n也叫做你他妈的想干嘛就干嘛公共许可证\n\n想怎么搞怎么搞, 祝你心想事成哟。\n\nWTFPL = Do What the Fuck You Want to Public License","n":0.116}}},{"i":21,"$":{"0":{"v":"Readme驱动开发（RDD）实践笔记","n":1},"1":{"v":"# Readme驱动开发（RDD）：提升软件开发效率与质量的新方法\n\n在软件开发领域，我们经常探讨如何提高开发效率和软件质量。近年来，一种名为Readme驱动开发（RDD）的方法引起了广泛关注。这种方法由GitHub的联合创始人Tom Preston-Werner提出，它强调在编写代码之前，首先创建一个清晰的Readme文档。\n\n## RDD的核心概念\n\nRDD是一种软件开发方法，它要求开发者在编写任何代码之前，先编写一个Readme文档。这个文档应该清晰地描述软件的用途、功能、API接口和使用方式。通过这种方式，RDD确保软件开发的方向和内容与用户需求相匹配，从而提高开发效率和软件质量。\n\n## RDD的优势\n\n1. **明确方向**：通过前期的文档编写，确保项目目标和需求清晰，避免在错误方向上浪费时间。\n2. **易于沟通**：Readme文档作为项目的第一份文档，有助于团队成员和其他利益相关者理解项目的目的和功能。\n3. **减少返工**：清晰的文档可以在早期发现问题，减少开发过程中的代码修改。\n4. **提高可维护性**：良好的文档有助于新成员快速了解项目，提高代码的可维护性。\n\n## 实施RDD的步骤\n\n1. **确定目标**：在编码前，明确软件需要解决的问题和目标用户群体。\n2. **编写Readme**：创建一个简洁明了的Readme文档，描述软件的用途、功能、API接口和使用方式。\n3. **团队讨论**：与团队成员一起审阅Readme文档，确保共同理解。\n4. **编码实现**：在Readme文档的指导下开始编码，确保每一步都符合文档描述。\n5. **持续更新**：随着项目进展，不断更新Readme文档，保持文档与代码的一致性。\n\n## 实践中的建议\n\n1. **简洁明了**：确保文档简洁，避免冗长和复杂术语。\n2. **使用示例**：提供清晰的使用示例，帮助用户快速理解如何使用项目。\n3. **项目结构**：组织清晰的项目文件和目录结构，便于其他开发者理解和参与。\n4. **贡献指南**：制定明确的贡献指南，鼓励社区成员参与项目。\n\n## 资讯来源\n\nTom Preston-Werner是RDD概念的提出者，他在自己的博客文章中有详细描述RDD的理念和实践方法。通过实践RDD，开发者可以更系统地规划和管理项目，提升开发效率和代码质量。这种方法适用于个人和团队项目，值得每位开发者尝试和实践。\n","n":0.213}}},{"i":22,"$":{"0":{"v":"React 源码分析 - 第一部分架构说明","n":0.5},"1":{"v":"# 从零开始搭建React源码工程讲座讲义\n\n一个培训机构面试的试讲讲义\n\n录课的时候发现以下问题, 但是代码仓库是全的\n\n用的话记得重头跑一遍来查漏补缺\n\n> * babel 安装有问题\n> * 创建文件路径有问题\n> * react index.ts 演示代码代码没有贴\n\n代码库:\n\nhttps://gitee.com/imyyliang/react-clone\n\n## 课程目标\n\n本课程旨在带领学员从零开始搭建一个与React官方工程结构相近的源码工程。我们将使用Rollup进行编译打包，Jest进行测试，pnpm进行包管理，并搭建一个monorepo结构的多包工程。课程将涵盖以下内容：\n\n1. 项目初始化与目录结构搭建\n2. 配置TypeScript与ESLint\n3. 使用Rollup进行打包\n4. 使用Jest进行单元测试\n5. 搭建monorepo结构并处理模块间依赖\n6. 创建示例页面并实现热更新\n\n## 课程大纲\n\n### 1. 项目初始化与目录结构搭建\n\n#### 1.1 创建项目\n\n首先，我们创建一个新的项目目录并初始化项目。\n\n```bash\nmkdir react-clone\ncd react-clone\npnpm init\ngit init\ngit add .\ngit commit -m '初始化'\n```\n\n#### 1.2 准备文件夹和文件\n\n接下来，我们创建项目的目录结构，并为每个模块准备必要的文件。\n\n```bash\nmkdir packages scripts\ntouch eslint.config.js\n\ncd packages\nmkdir react react-dom scheduler\nmkdir react/src\nmkdir react/src/__test__\ntouch react/src/index.ts react/src/__test__/index.test.ts\n# 上面两个文件也复制到 react-dom 和 scheduler\n\ncd ../scripts\nmkdir rollup jest babel\ntouch jest\\jest.config.js babel\\babel.config.js rollup\\rollup.config.js\n\ncd ..\n```\n\n### 2. 配置TypeScript与ESLint\n\n#### 2.1 配置TypeScript\n\n在根目录下创建`tsconfig.json`文件，并配置TypeScript编译选项。\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ESNext\",\n    \"module\": \"ESNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"moduleResolution\": \"node\",\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"importHelpers\": true,\n    \"lib\": [\"dom\", \"ESNext\"]\n  },\n  \"include\": [\"packages/**/*\", \"scripts/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n#### 2.2 配置ESLint\n\n在根目录下创建`eslint.config.js`文件，并配置ESLint规则。\n\n```js\nconst path = require('path');\n\nmodule.exports = [\n  {\n    files: ['packages/**/*.ts', 'scripts/**/*.ts'],\n    ignores: ['**/node_modules/**/*', '**/dist/**/*', '**/build/**/*'],\n    languageOptions: {\n      parserOptions: {\n        ecmaVersion: 'latest',\n        sourceType: 'module',\n        project: path.resolve(__dirname, './tsconfig.json'),\n      },\n      parser: require('@typescript-eslint/parser'), // 确保使用 TypeScript 解析器\n    },\n    plugins: {\n      '@typescript-eslint': require('@typescript-eslint/eslint-plugin'),\n    },\n    rules: {\n      '@typescript-eslint/explicit-module-boundary-types': 'off',\n      '@typescript-eslint/no-explicit-any': 'off',\n      'no-console': 'warn',\n      '@typescript-eslint/no-unused-vars': ['error'],\n    },\n    settings: {\n      'import/resolver': {\n        typescript: {\n          project: path.resolve(__dirname, './tsconfig.json'),\n        },\n      },\n    },\n  },\n];\n```\n\n#### 2.3 安装依赖\n\n安装TypeScript和ESLint相关依赖。\n\n```bash\npnpm add -D -w eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin typescript\n```\n\n#### 2.4 测试ESLint配置\n\n在任何一个`src/index.ts`文件中写入`console.log`，然后运行`pnpm lint`，应该会看到警告信息。\n\n### 3. 使用Rollup进行打包\n\n#### 3.1 安装Rollup及相关插件\n\n安装Rollup及其插件。\n\n```bash\npnpm add -D -w rollup rollup-plugin-commonjs rollup-plugin-node-resolve rollup-plugin-typescript\n```\n\n#### 3.2 配置Rollup\n\n在`scripts/rollup/rollup.config.js`中配置Rollup。\n\n```js\nconst resolve = require('rollup-plugin-node-resolve');\nconst commonjs = require('rollup-plugin-commonjs');\nconst typescript = require('rollup-plugin-typescript');\nconst path = require('path');\nconst fs = require('fs');\n\n// 获取所有模块的路径\nconst packagesDir = path.resolve(__dirname, '../../packages');\nconst packages = fs.readdirSync(packagesDir).filter(pkg => {\n  const stat = fs.statSync(path.join(packagesDir, pkg));\n  return stat.isDirectory();\n});\n\n// 构建每个模块的输入和输出配置\nconst inputConfigs = packages.map(pkg => ({\n  input: path.join(packagesDir, pkg, 'src', 'index.ts'), // 每个模块的入口\n  output: [\n    {\n      file: path.join(packagesDir, pkg, 'dist', 'index.umd.js'),\n      format: 'umd',\n      name: pkg.charAt(0).toUpperCase() + pkg.slice(1), // 生成全局名称\n    },\n    {\n      file: path.join(packagesDir, pkg, 'dist', 'index.esm.js'),\n      format: 'esm',\n    },\n    {\n      file: path.join(packagesDir, pkg, 'dist', 'index.cjs.js'),\n      format: 'cjs',\n    },\n  ],\n  plugins: [\n    resolve(),\n    commonjs(),\n    typescript()\n  ],\n}));\n\nmodule.exports = inputConfigs;\n```\n\n#### 3.3 配置`package.json`\n\n在`package.json`中添加`build`脚本。\n\n```json\n  \"scripts\": {\n    \"lint\": \"eslint\",\n    \"build\": \"rollup -c scripts/rollup/rollup.config.js\"\n  },\n```\n\n#### 3.4 测试Rollup配置\n\n运行`pnpm build`命令，应该会生成各个模块下方的`dist/index.xxx.js`文件。\n\n### 4. 使用Jest进行单元测试\n\n#### 4.1 安装Jest及相关依赖\n\n安装Jest及其相关依赖。\n\n```bash\npnpm add -D -w jest jest-environment-jsdom @types/jest babel-jest\n```\n\n#### 4.2 配置Jest\n\n在`scripts/jest/jest.config.js`中配置Jest。\n\n```js\nmodule.exports = {\n  transform: {\n    '^.+\\\\.ts$': ['babel-jest', {configFile: require.resolve('../babel/babel.config.js')}],\n  },\n  rootDir: process.cwd(),\n  roots: ['<rootDir>/packages', '<rootDir>/scripts'],\n  testEnvironment: 'jsdom'\n};\n```\n\n#### 4.3 配置Babel\n\n在`scripts/babel/babel.config.js`中配置Babel。\n\n```js\n// scripts/babel/babel.config.js\nmodule.exports = {\n  presets: [\n    ['@babel/preset-env', { targets: { node: 'current' } }],\n    '@babel/preset-typescript',\n  ]\n};\n```\n\n#### 4.4 编写测试用例\n\n在`packages/react/src/__test__/index.test.ts`中编写测试用例。\n\n```js\nimport { React } from '..';\n\ntest('创建一个div元素', () => {\n  const element1 = React.createElement('div', {}, '这是一个div元素');\n  expect(element1.type).toBe('div');\n  expect(element1.props).toEqual({});\n  expect(element1.children[0]).toBe('这是一个div元素');\n});\n\ntest('创建一个p元素，带有属性class=\"myClass\"', () => {\n  const element2 = React.createElement('p', { class: 'myClass' }, '这是一个p元素');\n  expect(element2.type).toBe('p');\n  expect(element2.props).toEqual({ class: 'myClass' });\n  expect(element2.children[0]).toBe('这是一个p元素');\n});\n\ntest('创建一个div元素，包含一个p元素', () => {\n  const element3 = React.createElement('div', {}, React.createElement('p', {}, '这是一个p元素'));\n  expect(element3.type).toBe('div');\n  expect(element3.props).toEqual({});\n  expect(element3.children[0].type).toBe('p');\n  expect(element3.children[0].props).toEqual({});\n  expect(element3.children[0].children[0]).toBe('这是一个p元素');\n});\n```\n\n#### 4.5 配置`package.json`\n\n在`package.json`中添加`test`脚本。\n\n```json\n  \"scripts\": {\n    \"lint\": \"eslint\",\n    \"build\": \"rollup -c scripts/rollup/rollup.config.js\",\n    \"test\": \"jest -c scripts/jest/jest.config.js\"\n  },\n```\n\n#### 4.6 测试Jest配置\n\n运行`pnpm test`命令，应该会运行所有测试用例并输出结果。\n\n### 5. 搭建monorepo结构并处理模块间依赖\n\n#### 5.1 初始化monorepo\n\n在每个模块目录下执行`pnpm init`，并修改生成的`package.json`文件，将`main`字段改为`src/index.ts`。\n\n```bash\ncd packages/react\npnpm init\n# 修改 package.json 中的 main 字段为 src/index.ts\n\ncd ../react-dom\npnpm init\n# 修改 package.json 中的 main 字段为 src/index.ts\n\ncd ../scheduler\npnpm init\n# 修改 package.json 中的 main 字段为 src/index.ts\n```\n\n#### 5.2 配置工作区\n\n在根目录下创建`pnpm-workspace.yaml`文件，配置工作区。\n\n```yaml\npackages:\n  - 'packages/*'\n```\n\n#### 5.3 处理模块间依赖\n\n在`react`模块的`package.json`中添加对`scheduler`模块的依赖。\n\n```json\n  \"dependencies\": {\n    \"scheduler\": \"workspace:*\"\n  }\n```\n\n在`react`模块目录下运行`pnpm install`。\n\n#### 5.4 测试monorepo配置\n\n在`react`模块中使用`scheduler`模块，并编写测试用例。\n\n```js\nimport { Scheduler } from 'scheduler'\nexport class React {\n  static createElement(type: string, props: any, ...children: any[]) {\n    return { type, props, children };\n  }\n\n  static scheduleReconciliation() {\n    Scheduler.scheduleWork(() => {\n      console.log('Reconciling...');\n    });\n  }\n}\n```\n\n```js\nimport { React } from '..';\nimport { Scheduler } from 'scheduler';\n\njest.mock('scheduler', () => ({\n  Scheduler: {\n    scheduleWork: jest.fn()\n  }\n}));\n\ndescribe('React 类', () => {\n  describe('createElement 方法', () => {\n    test('创建一个div元素', () => {\n      const element1 = React.createElement('div', {}, '这是一个div元素');\n      expect(element1.type).toBe('div');\n      expect(element1.props).toEqual({});\n      expect(element1.children[0]).toBe('这是一个div元素');\n    });\n\n    test('创建一个p元素，带有属性class=\"myClass\"', () => {\n      const element2 = React.createElement('p', { class: 'myClass' }, '这是一个p元素');\n      expect(element2.type).toBe('p');\n      expect(element2.props).toEqual({ class: 'myClass' });\n      expect(element2.children[0]).toBe('这是一个p元素');\n    });\n\n    test('创建一个div元素，包含一个p元素', () => {\n      const element3 = React.createElement('div', {}, React.createElement('p', {}, '这是一个p元素'));\n      expect(element3.type).toBe('div');\n      expect(element3.props).toEqual({});\n      expect(element3.children[0].type).toBe('p');\n      expect(element3.children[0].props).toEqual({});\n      expect(element3.children[0].children[0]).toBe('这是一个p元素');\n    });\n  });\n\n  describe('scheduleReconciliation 方法', () => {\n    test('应该调用 Scheduler.scheduleWork', () => {\n      React.scheduleReconciliation();\n      expect(Scheduler.scheduleWork).toHaveBeenCalled();\n    });\n  });\n});\n```\n\n运行`pnpm test`进行测试。\n\n### 6. 创建示例页面并实现热更新\n\n#### 6.1 准备模块文件\n\n创建`example`模块，并准备必要的文件。\n\n```bash\nmkdir packages/example\ncd packages/example\ntouch index.html index.ts\npnpm init\n```\n\n#### 6.2 配置`example`模块\n\n在`example/index.html`中编写HTML文件。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>React Example</title>\n</head>\n<body>\n  <div id=\"root\"></div>\n  <script src=\"dist/bundle.js\"></script>\n</body>\n</html>\n```\n\n在`example/index.ts`中编写TypeScript代码。\n\n```js\nimport { React } from 'react';\nimport { ReactDOM } from 'react-dom';\n\nconst element = React.createElement(\n  'div',\n  null,\n  React.createElement('h1', null, 'Hello, World!'),\n  React.createElement('p', null, 'This is a simple React component.')\n);\n\nReactDOM.render(element, document.getElementById('root')!);\n```\n\n在`example/package.json`中添加依赖。\n\n```json\n  \"dependencies\": {\n    \"react\": \"workspace:*\",\n    \"react-dom\": \"workspace:*\"\n  }\n```\n\n在`example`模块目录下运行`pnpm install`。\n\n#### 6.3 配置Rollup\n\n在`scripts/rollup/rollup.config.js`中配置Rollup，支持热更新。\n\n```js\nconst resolve = require('rollup-plugin-node-resolve');\nconst commonjs = require('rollup-plugin-commonjs');\nconst typescript = require('rollup-plugin-typescript');\nconst serve = require('rollup-plugin-serve');\nconst livereload = require('rollup-plugin-livereload');\nconst path = require('path');\nconst fs = require('fs');\nconst { execSync } = require('child_process');\n\nconst packagesDir = path.resolve(__dirname, '../../packages');\n\n// 获取命令行参数\nconst argv = process.argv.slice(2);\nconst isWatchMode = argv.includes('-w') || argv.includes('--watch');\n\n// 获取所有模块的路径\nconst packages = fs.readdirSync(packagesDir).filter(pkg => {\n  const stat = fs.statSync(path.join(packagesDir, pkg));\n  return stat.isDirectory() && pkg !== 'example';\n});\n\n// 构建每个模块的输入和输出配置\nconst buildPackageConfig = (pkg) => ({\n  input: path.join(packagesDir, pkg, 'src', 'index.ts'),\n  output: [\n    {\n      file: path.join(packagesDir, pkg, 'dist', 'index.umd.js'),\n      format: 'umd',\n      name: pkg.charAt(0).toUpperCase() + pkg.slice(1),\n    },\n    {\n      file: path.join(packagesDir, pkg, 'dist', 'index.esm.js'),\n      format: 'esm',\n    },\n    {\n      file: path.join(packagesDir, pkg, 'dist', 'index.cjs.js'),\n      format: 'cjs',\n    },\n  ],\n  plugins: [\n    resolve(),\n    commonjs(),\n    typescript(),\n  ],\n});\n\n// 构建 example 页面的打包配置\nconst buildExampleConfig = () => ({\n  input: path.join(packagesDir, 'example', 'index.ts'),\n  output: {\n    file: path.join(packagesDir, 'example', 'dist', 'bundle.js'),\n    format: 'iife',\n    sourcemap: true,\n  },\n  plugins: [\n    resolve(),\n    commonjs(),\n    typescript(),\n    serve({\n      contentBase: [path.join(packagesDir, 'example')],\n      port: 3000,\n    }),\n    livereload({\n      watch: path.join(packagesDir, 'example', 'dist'),\n    }),\n  ],\n});\n\n// 根据模式选择配置\nconst inputConfigs = isWatchMode\n  ? [buildExampleConfig()]\n  : packages.map(buildPackageConfig);\n\n// 在所有模块打包完成后安装依赖\ninputConfigs.forEach(config => {\n  config.plugins.push({\n    name: 'pnpm-install',\n    buildEnd() {\n      console.log(`Running pnpm install for ${config.input}`);\n      execSync('pnpm install', { cwd: path.dirname(config.input) });\n    },\n  });\n});\n\n// 导出所有配置\nmodule.exports = inputConfigs;\n```\n\n#### 6.4 配置`package.json`\n\n在`package.json`中添加`start`脚本。\n\n```json\n  \"scripts\": {\n    \"lint\": \"eslint\",\n    \"build\": \"rollup -c scripts/rollup/rollup.config.js\",\n    \"test\": \"jest -c scripts/jest/jest.config.js\",\n    \"start\": \"rollup -c scripts/rollup/rollup.config.js -w\"\n  },\n```\n\n#### 6.5 运行测试\n\n在根目录下运行`pnpm start`，然后打开`http://localhost:3000/`，应该能看到页面，同时修改`example/index.ts`可以测试热更新功能。\n\n## 总结\n\n通过本课程，我们成功搭建了一个与React官方工程结构相近的源码工程。我们使用了Rollup进行打包，Jest进行单元测试，pnpm进行包管理，并搭建了一个monorepo结构的多包工程。我们还创建了一个示例页面并实现了热更新功能。希望本课程能帮助你更好地理解React源码工程的搭建过程。","n":0.035}}},{"i":23,"$":{"0":{"v":"Docker镜像拉取困难？看这里！阿里云部署Dashy的成功案例","n":1},"1":{"v":"嘿，亲爱的小伙伴们！今天我们要探讨的是一个不少开发者在阿里云服务器上部署Dashy面板时遇到的难题——Docker镜像无法拉取的情况。遇到这种情况时，别担心，本文将带你一步步解锁解决方案，让你的云端之旅更加顺畅！\n\n### 前情回顾\n\n某一天，我决定在我的阿里云服务器上部署一个个性化导航页——Dashy面板。满怀期待地开始了我的部署旅程，却在第一步就遇到了阻碍。使用`docker pull lissy93/dashy:latest`时，要么是长时间的等待超时，要么是直接返回失败的信息。这无疑是个不小的打击，但我并没有放弃。\n\n### 痛点分析\n\n在国内的网络环境中部署Dashy时，我们可能会遭遇以下几个挑战：\n\n- **网络延迟**：由于Dashy的Docker镜像是托管在国外，从国内访问时可能会出现响应慢甚至无法连接的问题。\n- **安全限制**：防火墙策略或DNS解析问题可能导致与国外Docker Hub的连接中断。\n- **代理设置**：缺乏有效的代理工具或服务也可能成为拉取镜像的障碍。\n\n### 解决方案：本地搬运法\n\n为了克服这些问题，我们可以采用“本地搬运法”来解决。这种方法的核心思想是先在本地环境中下载所需镜像，然后将镜像文件传输到阿里云服务器，并在服务器上加载该镜像。以下是详细的步骤：\n\n#### 1. 准备工作\n\n确保本地电脑上已经安装了Docker，并且能够正常使用：\n\n```shell\n# 检查Docker版本\ndocker --version\n\n# 确认Docker服务正在运行\nsystemctl status docker\n```\n\n#### 2. 本地拉取镜像\n\n使用以下命令在本地环境中下载Dashy的Docker镜像：\n\n```shell\ndocker pull lissy93/dashy:latest\n```\n\n#### 3. 保存镜像文件\n\n将下载好的镜像保存为`.tar`文件，便于传输：\n\n```shell\ndocker save -o dashy.tar lissy93/dashy:latest\n```\n\n#### 4. 上传至云服务器\n\n通过FTP/SFTP或SCP等工具将`.tar`文件上传到阿里云服务器：\n\n```shell\nscp localpath/dashy.tar username@yourserver:/remote/path/\n```\n\n#### 5. 在云端加载镜像\n\n最后，在阿里云服务器上使用以下命令加载镜像：\n\n```shell\ndocker load -i /remote/path/dashy.tar\n```\n\n完成以上步骤后，你就可以在阿里云服务器上启动Dashy容器了：\n\n```shell\ndocker run -id --name dashy -p 8080:80 lissy93/dashy\n```\n\n此时，打开浏览器访问阿里云服务器的IP地址加上8080端口，就能看到Dashy面板的界面了。\n\n### 总结\n\n通过上述步骤，即使是在国内网络环境下，我们也能够顺利地将Docker镜像部署到阿里云服务器上。这个过程虽然多了一步本地搬运，但却能够有效避免直接从国外拉取镜像时可能遇到的各种问题。希望这个小技巧能够帮助到大家，让你们在探索云计算的路上更加得心应手！\n\n如果你在实践中遇到了其他问题，或是有任何疑问，欢迎随时留言交流。祝各位开发者朋友们都能顺利部署自己的项目，享受编程的乐趣！","n":0.151}}},{"i":24,"$":{"0":{"v":"2023 年文章","n":0.707}}},{"i":25,"$":{"0":{"v":"前端 Vue 基本功自测","n":0.577},"1":{"v":"# 目的\n下面都是一些考察 vue 使用的题目, 能写出来不一定能找到工作, 但是不会写, 证明你没有学会 vue.\n# 题目\n- 编写一个计数器的功能，并能够实现加减操作。\n- 编写表格，并实现分页功能。要求使用 element-ui 的表格组件，表格内容先写死一百条假数据。\n- 编写一个导航栏，并能够实现在不同页面之间的跳转。要求使用 vue-router 嵌套路由实现。并在跳转之间传递和获取参数。\n- 编写购物车功能，预先写好假数据，并能够实现删除商品、数量调整等功能。要求使用 Vuex 管理共享数据。\n- 编写留言板功能。要求使用 Axios 发送 HTTP 请求获取留言数据，并能够实现新增留言、删除留言等功能。(下面有数据模拟说明)\n- 编写一个 Vue2 组件，实现一个简单的日历功能。要求使用 element-ui 的日期选择器组件，并能够动态传入默认日期、日期范围功能。\n# 配套数据\n附上使用 json-server 模拟留言板接口的方法\n\n1. 安装json-server：\n\n```\nnpm install -g json-server\n```\n\n2. 创建一个名为`db.json`的文件，用于存储模拟的留言数据。在项目根目录下创建这个文件，并添加一些初始数据：\n\n```json\n{\n  \"messages\": [\n    { \"id\": 1, \"text\": \"第一条留言\" },\n    { \"id\": 2, \"text\": \"第二条留言\" }\n  ]\n}\n```\n\n3. 启动json-server来模拟后台数据：\n\n```\njson-server --watch db.json --port 3000\n```\n\n这将在端口3000上启动json-server，并使用`db.json`文件中的数据。\n\n以下是用于留言板功能的基本接口文档，这些接口是与json-server模拟的后台数据进行交互的。\n\n#### 获取留言列表\n\n- **URL**: `GET /messages`\n- **描述**: 获取所有留言的列表\n- **响应示例**:\n\n```json\n[\n  {\n    \"id\": 1,\n    \"text\": \"第一条留言\"\n  },\n  {\n    \"id\": 2,\n    \"text\": \"第二条留言\"\n  }\n]\n```\n\n#### 添加新留言\n\n- **URL**: `POST /messages`\n- **描述**: 添加新留言\n- **请求体**:\n\n```json\n{\n  \"text\": \"新留言内容\"\n}\n```\n\n- **响应示例**:\n\n```json\n{\n  \"id\": 3,\n  \"text\": \"新留言内容\"\n}\n```\n\n#### 删除留言\n\n- **URL**: `DELETE /messages/:id`\n- **描述**: 删除指定ID的留言\n- **示例**:\n\n```\nDELETE /messages/2\n```\n\n- **响应示例**:\n\n```json\n{}\n```\n\n这些接口允许你通过HTTP请求来获取留言列表、添加新留言和删除指定ID的留言。","n":0.101}}},{"i":26,"$":{"0":{"v":"Vue-Admin-Work 运行时 Codemirror 错误解决方案","n":0.5},"1":{"v":"在使用 `vue-admin-work` 的 Vue2 版本时，你可能会遇到与 `Codemirror` 相关的错误。本文将指导你如何解决这一问题，并提供一种长久的解决方案。\n\n## 报错信息\n当你尝试运行项目时，可能会看到如下依赖缺失的错误：\n\n```\nThese dependencies were not found:\n\n* codemirror/addon/display/fullscreen.js in ./node_modules/simplemde/src/js/simplemde.js\n* codemirror/addon/display/placeholder.js in ./node_modules/simplemde/src/js/simplemde.js\n* codemirror/addon/edit/continuelist.js in ./node_modules/simplemde/src/js/simplemde.js\n* codemirror/addon/mode/overlay.js in ./node_modules/simplemde/src/js/simplemde.js\n* codemirror/addon/selection/mark-selection.js in ./node_modules/simplemde/src/js/simplemde.js\n* codemirror/mode/gfm/gfm.js in ./node_modules/simplemde/src/js/simplemde.js\n* codemirror/mode/markdown/markdown.js in ./node_modules/simplemde/src/js/simplemde.js\n* codemirror/mode/xml/xml.js in ./node_modules/simplemde/src/js/simplemde.js\n```\n\n## 问题原因\n该框架使用了 `simplemde` 库，而这个库已经很久没有更新。由于其依赖版本定义中使用了通配符 `*`，导致安装时自动选择了最新版本的依赖，从而产生了兼容性问题。如果你使用的是 `npm` 并且有 `package-lock.json` 文件锁定版本，则可能不会出现此问题。但如果你使用 `yarn` 或 `pnpm` 等其他包管理工具，它们会安装最新的依赖，从而引发错误。\n\n## 解决方案\n\n### 简单方法\n1. 删除现有的 `node_modules` 文件夹。\n2. 使用 `npm i` 重新安装所有依赖。\n3. 在后续开发中始终使用 `npm` 来管理你的依赖。\n\n```shell\nrm -rf node_modules\nnpm i\n```\n\n### 长久之计\n`simplemde` 库已被废弃，你可以采用修改后的替代版本 `simplemde-w`。这个版本对依赖进行了更新，确保与当前环境兼容。\n\n#### 安装\n根据你使用的包管理工具选择对应的命令：\n\n- **npm**\n  ```shell\n  npm uninstall simplemde\n  npm i simplemde-w\n  ```\n\n- **yarn**\n  ```shell\n  yarn remove simplemde\n  yarn add simplemde-w\n  ```\n\n- **pnpm**\n  ```shell\n  pnpm remove simplemde\n  pnpm add simplemde-w\n  ```\n\n#### 使用\n全局搜索并替换引入 `simplemde` 的地方为 `simplemde-w`。\n\n例如：\n```javascript\n// 旧代码\n// import 'simplemde/dist/simplemde.min.css'\n// import SimpleMDE from 'simplemde'\n\n// 新代码\nimport 'simplemde-w/dist/simplemde.min.css'\nimport SimpleMDE from 'simplemde-w'\n```\n\n希望这些步骤能够帮助你解决问题。如果还有其他疑问或更好的解决方案，请在评论区分享你的经验！","n":0.095}}},{"i":27,"$":{"0":{"v":"2017 年文章","n":0.707}}},{"i":28,"$":{"0":{"v":"网页设计定价：揭秘背后的故事","n":1},"1":{"v":"(翻译作品)\n\n网页设计的价格是一个复杂且敏感的话题。在这个领域，无论是对于寻求服务的客户还是提供服务的设计者来说，理解价格背后的逻辑都至关重要。本文旨在为那些可能不太熟悉网页设计行业的人们揭开这层面纱，探讨一些关键的问题，并提供一些建议。\n\n## 我不是专家，但这是我的观察\n\n首先声明，我并非这个行业的资深人士，也无意声称自己是权威。我的目标不是建立一套适用于所有情况的计费模式，而是基于个人经验和观察分享见解。\n\n## 了解网页设计师的不同类型\n\n在寻找合适的网页设计师时，您可能会遇到以下几类专业人士：\n\n- **传播公司**：这类公司通常能够提供一站式服务，包括从概念到执行的全流程支持。\n- **自由职业设计师**：独立工作的设计师，他们往往具有灵活性，可以提供个性化的服务。\n- **业余兼职者**：这些通常是初学者或爱好者，希望通过实践来提升自己的技能。\n\n每一种类型都有其优势和局限性，重要的是要根据您的具体需求做出选择。\n\n## 价格差异的背后\n\n当涉及到费用时，不同的设计师会给出非常不同的报价。比如，一家传播公司可能会对一个简单的网站收取至少700欧元；而一位自由职业者由于运营成本较低，可能会将价格降至500欧元左右；至于那些正在学习中的新手，则可能只收50欧元甚至更低。\n\n这种巨大的价差反映了几个因素：经验水平、作品质量、所需时间和额外服务等。值得注意的是，极低的价格往往意味着牺牲了某些方面的质量或是利用了设计师缺乏经验的情况。\n\n## 避免低价陷阱\n\n虽然低价似乎很有吸引力，但实际上，它往往伴随着风险。过于低廉的价格可能导致得到的结果不尽如人意，同时也会给努力工作的新手带来不公平的压力。此外，这种情况还会导致市场价格混乱，影响整个行业的健康发展。\n\n### 对于设计师的建议\n- **不要急于出售你的设计**：确保你所提供的价值与所要求的报酬相匹配。\n- **设立合理的起始价**：对于自由职业者而言，每天的工作（假设8小时）至少应该收费200欧元，以覆盖生活成本及业务开销。\n- **考虑长期发展**：投资于自身能力的增长，随着技艺提高，逐步调整你的收费标准。\n\n### 给客户的提示\n- **重视质量而非仅仅关注价格**：一个好的设计能够显著提升品牌形象并吸引潜在顾客。\n- **做足研究**：查看设计师过去的作品案例，了解他们的风格是否符合您的期望。\n- **沟通明确**：事先讨论好项目范围、预算限制以及完成时间表，避免后期出现误解。\n\n## 结论\n网页设计的价值不仅仅体现在最终产品上，还包括设计师投入的时间、创意和技术。设定合理的价格对于维护行业标准至关重要。希望这篇文章能帮助大家更好地理解和欣赏网页设计背后的努力。如果您有任何想法或者想要分享的经验，请随时留言交流。","n":0.243}}},{"i":29,"$":{"0":{"v":"网站价值几何？","n":1},"1":{"v":"(翻译作品)\n电子商城及企业网站价格解析\n当您在线搜索网站建设的价格时，会发现从免费到上千欧元不等的各种选项。那么，这些不同价位的网站服务到底能提供什么呢？\n\n## 免费网站\n这种类型的网站往往物有所值，但也仅此而已。它们通常具备以下特点：\n\n- 所有权问题：您并不真正拥有网站；服务商可能随时关闭服务。\n- 广告泛滥：您的网站可能会被广告包围，甚至包括竞争对手的广告。\n- 技术支持缺失：真正的技术支持服务不可能是免费提供的。\n- 个性化受限：通过免费服务提供的自定义选项极其有限。\n\n## 几欧元至几十欧元的网站\n这类网站服务可能看起来很吸引人，但实际体验可能会令人失望：\n\n- 质量参差不齐：最糟糕的情况下，它们和免费服务一样毫无价值。\n- 投资回报低：即使在最佳情况下，您的时间和金钱投入也可能因为服务限制而白费。\n- 服务水平不足：缺乏快速响应的技术支持，难以构建出有吸引力的网站。\n- 现成模板：只能使用预设好的网站模板，几乎没有定制空间。\n- 性能低下：服务器性能不佳，功能有限。\n\n## 您是否真的需要一个专业网站？\n如果您不具备网站设计与建设的专业技能，并且希望保持专业的线上形象，那么答案是肯定的。没有一个高质量的网站，您可能会错过潜在客户并失去商业机会。\n\n## 网站服务的成本考量\n计算网站服务的实际成本相对直接。首先，考虑开发人员或自由职业者为了维持€1,500的月薪所需达到的营业额（约€3,000）。这意味着他们的真实收入大约只有收费的一半。对于客户而言，这部分费用可以作为税务抵扣。\n\n接着，根据所需的各项服务（如设计、编程、技术维护等）来估算总成本。例如，一周的服务可能需要€750，半个月则为€1,500，一个月则是€3,000。显然，建立一个专业网站至少需要数天时间。\n\n## 高端定制网站\n对于那些寻求高度个性化解决方案的企业来说，数千乃至上万欧元的投资可能是合理的。这样的项目可能涉及大量的定制开发工作，远超出普通CMS工具的能力范围。\n\n## 警惕虚高报价\n然而，对于常规需求的网站，应警惕过高的报价。例如，安装谷歌分析代码这样的简单任务不应该超过25欧元。\n\n## 结论\n大多数企业在创建网站时的初始预算可以在1000至2000欧元之间，这已足够覆盖基本的设计、搭建以及托管费用。重要的是要记住，网站应当被视为一种投资，它可以帮助您吸引新客户并增加收益。确保选择合适的合作伙伴，以实现良好的投资回报率。","n":0.243}}},{"i":30,"$":{"0":{"v":"如何合理定价建站服务？","n":1},"1":{"v":"## 自由职业者的定价策略揭秘\n\n通常情况下，我的客户对我的报价感到满意，但也有一些客户认为价格偏高。这主要是因为他们在网上看到了诸如“1&1免费建站”之类的广告，以为创建一个网站就像按个按钮那么简单。\n\n## 客户的普遍误解\n“我有一个绝妙的想法！我们只需要复制那个（或这个）网站，然后稍微改动几个地方。” —— 这是21世纪典型的客户心态。\n但请允许我从专业角度出发来说明：拥有一个好的想法固然重要，但如果能提供具体的内容则更加理想。\n对于那些充满创意却缺乏预算、内容和计划的客户\n如果你们期待以每月几十欧元的价格获得包括但不限于域名注册、个性化设计、网站构建、新功能开发、响应式布局优化以及流量分析等一站式服务，那么这样的要求实在是有些不切实际。\n\n## 自由职业者的真实成本\n作为自由职业者，以下是我必须承担的一些基本开销：\n\n硬件与软件投资：虽然我会选择开源解决方案来减少成本，但是购置必要的硬件仍然是不可或缺的一环。\n持续学习与发展：为了保持竞争力，每月大约需要花费50欧元左右购买书籍和订阅杂志，以便紧跟行业最新趋势。\n生活开支：涵盖保险、房租、日常饮食及交通费用等。\n这些支出远非区区几十欧元能够覆盖。\n\n## 网站建设成本估算基础\n在制定网站报价时，至少要考虑以下三个关键因素：\n\n- 目标收入：即希望达到的日薪或月薪标准。\n- 工作时长：完成项目所需的时间投入。\n- 休息时间：保证生活质量的同时安排适当休假。\n\n结合项目的复杂度及预计工时，便可以大致推算出一个合理的网站建设费用范围了。\n\n当然，以上仅是一种简化的计算方法，并不能完全代表最终报价流程。但它应该有助于您理解为什么一个既美观又实用且易于访问的专业网站值得其价值所在。","n":0.316}}},{"i":31,"$":{"0":{"v":"WordPress 迁移后遇到的问题及解决方案","n":0.707},"1":{"v":"## 概述\n在将WordPress网站迁移到新的服务器之后，您可能会遇到一些问题，比如后台媒体库中没有显示已上传的图片，以及无法选择页面模板。这些问题虽然表现形式不同，但可能源自同一个根本原因。本文将探讨这一问题，并提供一个有效的解决方法。\n\n## 问题一：媒体库无图片显示\n当您完成WordPress站点的迁移后，如果发现文章或页面中的图片可以正常加载，但是在媒体库中却看不到这些图片，这通常意味着文件实际存在于服务器上，但是WordPress后台无法读取到它们。\n\n### 可能的原因\n- **权限设置不正确**：确保您的图片文件夹权限允许WordPress访问。\n- **PHP配置限制**：某些服务器出于安全考虑，默认禁用了`scandir`等函数，这会阻止WordPress扫描并列出目录下的文件。\n\n## 问题二：页面模板不可选\n如果您尝试创建新页面时发现无法选择特定模板，即使是在使用成熟主题的情况下也是如此，那么这也可能是由于同样的PHP配置问题导致的。有时，开发者忘记给自定义模板添加`Template Name`标签确实会导致此类问题；但对于广泛使用的、经过充分测试的主题来说，这种情况非常罕见。\n\n### 解决方案\n幸运的是，上述两个问题都可以通过调整服务器上的PHP配置来解决。具体步骤如下：\n\n1. 登录至您的服务器，找到并编辑`php.ini`文件。\n2. 查找`disable_functions`参数。该参数用于指定禁止执行的PHP函数列表。\n3. 从列表中删除`scandir`（如果有）以解除对该功能的限制。\n4. 保存更改，并重启Web服务使配置生效。\n\n> [!注意]\n> 修改`php.ini`前，请确保备份原始文件。此外，对于非技术用户而言，建议联系您的主机提供商寻求帮助，因为他们能够更专业地处理此类修改。\n\n## 结语\n通过以上步骤，您可以解决因`scandir`被禁用而导致的媒体库图片缺失和页面模板选择受限的问题。记得定期检查您的网站功能是否正常运作，特别是在进行任何重大更新或迁移操作之后。希望本指南对您有所帮助！\n","n":0.25}}},{"i":32,"$":{"0":{"v":"2016 年文章","n":0.707}}},{"i":33,"$":{"0":{"v":"谁动了我的硬盘？电脑数据容量单位科普入门浅析","n":1},"1":{"v":"## 基础概念\n\n在日常生活中，我们习惯于使用十进制计数系统，它以10为基数，包含0到9这10个数字。当我们达到9后，就会进位变成10。然而，在电脑的世界里，由于电路的特性，区分十种状态比较复杂，而区分两种状态（如通电与不通电）则相对简单。这就是二进制的起源，它以2为基数，使用0和1两种状态。在二进制中，最基本的数据单位是**bit**（比特），它代表了二进制中的一位，可以存储一个二进制数字，即0或1。\n\n## 硬盘数据单位\n\n当我们谈论硬盘的存储容量时，最小的单位实际上是**byte**（字节）。一个字节由8个bit组成，每个bit有两种可能的状态，因此一个字节可以表示从00000000到11111111的256种不同的状态。在十进制中，这相当于0到255的256种可能的数据。\n\n## 单位转换\n\n在数据存储中，我们经常会遇到两个问题：\n\n1. **相同单位的进位**：无论是bit还是byte，它们都以1024为进位单位。例如，1024 bits（比特）等于1 kilobyte（KB），1024 kilobytes（KB）等于1 megabyte（MB），以此类推。\n\n2. **不同单位间的转换**：通常，bit和byte之间有8倍的差距。例如，8 bits等于1 byte，8 kilobits（Kb）等于1 kilobyte（KB），8 megabit（Mb）等于1 megabyte（MB）。\n\n## 现实生活中的应用\n\n### 硬盘容量\n\n在硬盘容量的标注上，计算机科学通常使用二进制的1024进位制，即1024 MB等于1 GB。然而，硬盘制造商通常使用十进制的1000进位制，即1000 MB等于1 GB。这种差异导致了我们购买的硬盘实际容量通常小于其标注的容量，主要原因是1024和1000之间的24的差距。\n\n### 网络速度\n\n另一个常见问题是，通信行业通常以bit为单位，而计算机行业则以byte为单位。由于它们之间大约有8倍的差距，网络供应商宣传的20M上网速度，实际上在计算机中观察到的极限下载速度需要除以8，即20Mbit/8 = 2.5Mbyte。因此，宣传的20兆上网速度实际上只有2.5M的极限下载速度。需要注意的是，这是理论上的极限速度，实际速度通常会受到线路老化、基站距离、信号干扰等因素的影响。根据我的经验，路由器能达到的下载速度通常在11到12Mbit，即1.4Mbyte左右。至于上传速度，通常更小，实际使用时大约在1Mbit，即128Kbyte左右。","n":0.2}}},{"i":34,"$":{"0":{"v":"如何在功能性和灵活性之间找到平衡？——以老版Wiz为知笔记为例","n":1},"1":{"v":"在软件设计领域，存在着两种截然不同的设计理念：一种是像微软Office那样追求“大而全”，力图提供一站式解决方案；另一种则是遵循Unix哲学的“KISS”（Keep It Simple, Stupid）原则，强调简洁性，专注于将单一任务做到极致。两者各有千秋，并无绝对优劣之分，选择哪一种取决于用户的具体需求和个人偏好。\n\n## 个人视角下的功能性与简洁性的权衡\n就我个人而言，我倾向于使用那些既能满足我的具体需求又不会因功能繁多而让人感到困惑的软件。插件化的设计似乎是一种理想的解决方式，它允许用户根据自己的需要安装特定的功能模块，从而实现定制化的体验。\n\n## 老版Wiz为知笔记的反思\n回顾对老版Wiz为知笔记的试用经历，该软件曾是国内较为出色的几款知识管理工具之一。然而，在初次接触时，我发现其预装了大量对我而言并不必要的组件，如GTD系统、通讯录等。这些额外的功能不仅没有帮助到我，反而造成了界面杂乱和操作上的不便。那时我就想，如果能够只挑选自己所需的特性来构建个人化的应用环境，那该有多好。\n\n## Wiz为知笔记的进化之路\n令人欣慰的是，随着版本更新，Wiz为知笔记已经朝着更加用户友好的方向发展。如今，它的界面变得更加清晰有序，对于深度用户来说，想要探索更多高级功能依旧容易可达；同时，新用户或轻度使用者也不会因为过多的选项而感到迷茫。这一转变表明，即便不采用插件机制，通过精心规划功能布局同样可以达到良好的用户体验效果。\n\n## 结语\n尽管Wiz为知笔记已经在很多方面取得了进步，但由于其服务器位于海外，导致我在实际使用过程中遇到了稳定性问题，最终还是选择了放弃这款产品。无论如何，这段经历让我深刻体会到了如何在保持强大功能的同时不失灵活简便的重要性。","n":0.354}}}]}
